#!/usr/bin/env bash
set -euo pipefail

# kill_port: find processes listening on a TCP port and terminate them
# Usage: ./kill_port [PORT] [-y]
# Defaults: PORT=5000

PORT=5000
AUTO_YES=0

if [[ ${1:-} == "-h" || ${1:-} == "--help" ]]; then
  cat <<EOF
Usage: $(basename "$0") [PORT] [-y|--yes]

Find processes listening on TCP PORT (default 5000) and terminate them.
Options:
  PORT        Port number to inspect (default 5000)
  -y, --yes   Do not prompt; kill found PIDs automatically
  -h, --help  Show this help
EOF
  exit 0
fi

# parse args
for arg in "$@"; do
  case "$arg" in
    -y|--yes)
      AUTO_YES=1
      ;;
    *)
      # If numeric, treat as port
      if [[ $arg =~ ^[0-9]+$ ]]; then
        PORT=$arg
      fi
      ;;
  esac
done

echo "Searching for processes listening on port $PORT..."

# Try ss first, then lsof fallback
PIDS=()
if command -v ss >/dev/null 2>&1; then
  # Extract pid numbers from ss output
  while IFS= read -r line; do
    # line contains users:("name",pid=1234,fd=...)
    if [[ $line =~ pid=([0-9]+) ]]; then
      PIDS+=("${BASH_REMATCH[1]}")
    fi
  done < <(ss -ltnp 2>/dev/null | grep -E ":$PORT\b" || true)
fi

if [ ${#PIDS[@]} -eq 0 ] && command -v lsof >/dev/null 2>&1; then
  while IFS= read -r pid; do
    PIDS+=("$pid")
  done < <(lsof -i TCP:$PORT -sTCP:LISTEN -Pn -t 2>/dev/null || true)
fi

# Deduplicate
if [ ${#PIDS[@]} -gt 0 ]; then
  # unique
  mapfile -t PIDS < <(printf "%s\n" "${PIDS[@]}" | sort -u)
fi

if [ ${#PIDS[@]} -eq 0 ]; then
  echo "No process found listening on port $PORT. Nothing to do."
  exit 0
fi

echo "Found PIDs listening on port $PORT: ${PIDS[*]}"

# Show process details
if command -v ps >/dev/null 2>&1; then
  echo
  ps -o pid,cmd -p "${PIDS[*]}" 2>/dev/null || true
  echo
fi

if [ "$AUTO_YES" -ne 1 ]; then
  read -r -p "Kill these processes? [y/N] " answer
  case "$answer" in
    [yY]|[yY][eE][sS]) ;;
    *) echo "Aborted."; exit 1;;
  esac
fi

# Attempt graceful termination, then force if needed
for pid in "${PIDS[@]}"; do
  if kill -0 "$pid" 2>/dev/null; then
    echo "Sending SIGTERM to $pid"
    kill "$pid" || true
  else
    echo "PID $pid is no longer running"
  fi
done

# wait up to 5s
echo "Waiting up to 5 seconds for processes to exit..."
for i in {1..5}; do
  sleep 1
  REMAINING=()
  for pid in "${PIDS[@]}"; do
    if kill -0 "$pid" 2>/dev/null; then
      REMAINING+=("$pid")
    fi
  done
  if [ ${#REMAINING[@]} -eq 0 ]; then
    echo "All processes exited cleanly."
    exit 0
  fi
done

# Force kill remaining
for pid in "${PIDS[@]}"; do
  if kill -0 "$pid" 2>/dev/null; then
    echo "Sending SIGKILL to $pid"
    kill -9 "$pid" || true
  fi
done

echo "Done."
